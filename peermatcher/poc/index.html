<!DOCTYPE html>
<html>
    <head>
        <script>
            const log = message => {
                const el = document.createElement('div')
                el.innerHTML = message
                document.getElementById('log').appendChild(el)
            }
            const logCount = (id, count) =>
                (document.getElementById(id).innerText = count.toString())

            const socket = new WebSocket('ws://localhost:3030')
            socket.onopen = () => log('Websocket is open.')
            socket.onerror = () => log('WebSocket error.')
            socket.onclose = ({ code, reason }) =>
                log(`WebSocket closed with error code ${code}.`)

            let idCounter = 0
            const SignalingChannel = function() {
                const id = idCounter++
                let resolver

                socket.addEventListener('open', () =>
                    socket.send(JSON.stringify({ id }))
                )
                socket.addEventListener('message', ({ data }) => {
                    try {
                        data = JSON.parse(data)
                    } catch {
                        return
                    }

                    if (data.id === undefined) {
                        socket.close()
                        return
                    }

                    if (id === data.id) {
                        if (data.candidate || data.description) {
                            this.onmessage({ data })
                        } else if (data.caller !== undefined) {
                            this.caller = data.caller
                            resolver()
                        }
                    }
                })

                this.ready = new Promise(resolve => (resolver = resolve))
                this.send = data => {
                    this.ready.then(() =>
                        socket.send(
                            JSON.stringify({
                                id,
                                candidate: data.candidate,
                                description: data.description,
                            })
                        )
                    )
                }

                return this
            }

            const peer = (peerConnectionConfiguration, i) => {
                const signaling = new SignalingChannel()
                let peerConnection
                let dataChannel
                let sentCounter = 0
                let receivedCounter = 0

                const createDataChannel = dataChannelFromEvent => {
                    dataChannel =
                        dataChannelFromEvent ||
                        peerConnection.createDataChannel('neighbor', {
                            // udp semantics
                            ordered: false,
                            maxRetransmits: 0,
                        })

                    let dataChannelInterval
                    dataChannel.onopen = () => {
                        log(`Data channel #${i} is open.`)
                        dataChannelInterval = setInterval(function() {
                            dataChannel.send('ping')
                            logCount(`sent${i}`, ++sentCounter)
                        }, 1)
                    }
                    dataChannel.onclose = () => {
                        log(`Data channel #${i} closed.`)
                        clearInterval(dataChannelInterval)
                    }
                    dataChannel.onmessage = () => {
                        logCount(`received${i}`, ++receivedCounter)
                    }
                }

                const createPeerConnection = () => {
                    peerConnection = new RTCPeerConnection(
                        peerConnectionConfiguration
                    )
                    peerConnection.ondatachannel = ({ channel }) =>
                        createDataChannel(channel)
                    peerConnection.onicecandidate = ({ candidate }) =>
                        !candidate || signaling.send({ candidate })
                    peerConnection.onnegotiationneeded = () =>
                        peerConnection
                            .createOffer()
                            .then(offer =>
                                peerConnection.setLocalDescription(offer)
                            )
                            .then(() =>
                                signaling.send({
                                    description:
                                        peerConnection.localDescription,
                                })
                            )
                            .catch(log)
                }

                signaling.onmessage = ({
                    data: { description, candidate },
                }) => {
                    if (!peerConnection) {
                        createPeerConnection()
                    }
                    if (description) {
                        if (description.type === 'offer') {
                            ;(peerConnection.signalingState != 'stable'
                                ? Promise.all([
                                      peerConnection
                                          .setLocalDescription({
                                              type: 'rollback',
                                          })
                                          .catch(log),
                                      peerConnection
                                          .setRemoteDescription(
                                              new RTCSessionDescription(
                                                  description
                                              )
                                          )
                                          .catch(log),
                                  ])
                                : peerConnection.setRemoteDescription(
                                      new RTCSessionDescription(description)
                                  )
                            )
                                .then(() =>
                                    peerConnection
                                        .createAnswer()
                                        .then(answer =>
                                            peerConnection.setLocalDescription(
                                                answer
                                            )
                                        )
                                        .then(() =>
                                            signaling.send({
                                                description:
                                                    peerConnection.localDescription,
                                            })
                                        )
                                )
                                .catch(log)
                        } else if (description.type === 'answer') {
                            peerConnection
                                .setRemoteDescription(
                                    new RTCSessionDescription(description)
                                )
                                .catch(log)
                        }
                    } else if (candidate) {
                        peerConnection
                            .addIceCandidate(new RTCIceCandidate(candidate))
                            .catch(log)
                    }
                }

                signaling.ready.then(() => {
                    if (signaling.caller) {
                        createPeerConnection()
                        createDataChannel()
                    }
                })
            }

            const numberOfPeers = 3
            for (let i = 0; i < numberOfPeers; i++) {
                peer(
                    {
                        iceServers: [
                            {
                                urls: ['stun:stun3.l.google.com:19302'],
                            },
                        ],
                    },
                    i
                )
            }
        </script>
    </head>
    <body>
        <!-- Table credits: https://www.w3schools.com/html/html_tables.asp -->
        <style>
            body {
                font-family: monospace;
            }
            table {
                border-collapse: collapse;
                width: 50%;
            }
            td,
            th {
                border: 1px solid #dddddd;
                text-align: left;
                padding: 8px;
            }
            tr:nth-child(even) {
                background-color: #dddddd;
            }
            #log div {
                padding: 2px;
            }
        </style>
        <div>
            <table>
                <colgroup>
                    <col span="1" style="width: 33%;" />
                    <col span="1" style="width: 33%;" />
                    <col span="1" style="width: 33%;" />
                </colgroup>

                <tr>
                    <th>Channels</th>
                    <th>Sent</th>
                    <th>Received</th>
                </tr>
                <tr>
                    <td>channel #0</td>
                    <td id="sent0"></td>
                    <td id="received0"></td>
                </tr>
                <tr>
                    <td>channel #1</td>
                    <td id="sent1"></td>
                    <td id="received1"></td>
                </tr>
                <tr>
                    <td>channel #2</td>
                    <td id="sent2"></td>
                    <td id="received2"></td>
                </tr>
            </table>

            <br />
            <h3>Log</h3>
            <div id="log"></div>
        </div>
    </body>
</html>
